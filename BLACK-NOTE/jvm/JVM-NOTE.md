JVM-NOTE

**minor GC全过程**

实例对象存储到堆内存，首先是存储于新生代Eden中

一直到Eden内存占满时，触发一次Minro GC，此时将存活的对象紧密复制到新生代Survovior01区，然后将Eden全部清除

等到Eden以及Survovior01区也存满时，触发Minor GC，将上述区存活对象存储至Survovior02区

如果Eden以及Survovior02区存放的存活对象存储至Survovior01区

以此往复，直到新生代对象年龄达到15或者另有其他设置值时，将会移动至老年代

或者动态分配，例如对象1+对象2的占用内存大于Survovior01区的总内存的一半时，将会把Survovior01区大于对象1对象2的年龄的所有对象复制到老年代

*有几类特殊情况*

1. Eden区一次gc后存活下来的对象太多，一个Survovior放不下，此时应该将这些对象存放至老年代
2. 接1，如果老年代的内存空间也不能存放这些对象[每次MinorGC都会去检测老年代可用的内存空间能不能存放所有新生代对象]，就会触发一次Full GC，即老年代的GC
3. Full GC之后，又会触发一次Minor GC，此时有三种情况，minorGC之后，存活对象可存放至survovior区，那么直接存放
4. 如果不行，那么尝试存放至老年代
5. 如果老年代也存放不下，会触发一次Full GC，清除老年代，如果还放不下，就会产生OOM



加入老年代规则：

**1.年龄** 默认在新生代存活15岁后进入

可通过JVM参数“-XX:MaxTenuringThreshold”来设置

**2.动态分配**  年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代

**3.设置大对象直接进入** 通过JVM参数“-XX:PretenureSizeThreshold”设置字节值[例如1048576字节，即1MB]，超过则直接进入老年代，而无需在新时代复制来复制去

**4.如果Eden区域gc后剩下的存活对象大于survivor区域的大小，则直接加入老年代**



注：*每次GC时都会去判断老年代可用的内存空间大小与当前新生代所有对象的大小*



老年代GC触发场景：

1.Minor GC之前检查发现老年代的可用空间不足以放下可能存活的对象，就会触发Full GC，然后再Minor GC

2.Minor GC之后老年代放不下这么多存活对象，就进行一次Full GC...



**parnew+cms的GC优化？**

优化思路：

*想要达到的目标：尽量减少Full GC，保证对象都在新生代，进入到老年代的速度较慢即可*

*尽量使存活时间短的对象都存活在新生代，存活时间长的尽快进入老年代*

1.分析每秒会新增多少对象在Eden，多长时间触发一次Minor GC，平均一次GC之后会有多少存活对象进入survivor区，该区域能否存放，还要判断不能因为动态年龄直接升入老年代

<u>注：动态分配  年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代</u>

2.可以把分代年龄适度增加，但是适可而止，因为可能会有许多@service，@controller之类的注解创建的对象会被滞留在新生代，这类对象一般还是放在老年代合适

3.修改新生代与老年代的比例，加大新生代

4.修改E区和S区的比例，同1，能让survivor放下GC之后的存活对象就行

5.由于每次GC都会提前去检查空间担保[JDK1.6之后默认检查]，要保证每次Minor GC之后存活的对象平均占用内存小于老年代可用内存，否则会触发Full GC



**G1的优化**

优化思路：

*避免对象过快的加入老年代，减少触发mixed GC*

*尽量使存活时间短的对象都存活在新生代，存活时间长的尽快进入老年代*

1.XX:MaxGCPauseMills

①这个参数用来设置GC时系统可接受的停滞时间，需要灵活变化，如果时间太短，那么对象在加入region之后G1回收器判定在这段短暂的时间内我可以把这些只占用了一丢丢的region给回收掉将会频繁触发GC

②如果时间太长，系统可能容忍你一直添加新对象，最后再一次性回收个几百M，此时系统停滞个500ms

③时间如果太长还有另一个问题，此时新生代累计了许多对象，可能达到占用堆内存的60%，才触发了一次新生代的GC，这个时候存活的对象可能超过了survivor的内存大小或者由于动态年龄判断，会使得存活对象加入老年代，如果老年代region占用了堆内存的45%，那么又会触发一次mixed GC
