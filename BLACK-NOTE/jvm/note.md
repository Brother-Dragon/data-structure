加入老年代规则：

**1.年龄** 默认在新生代存活15岁后进入

可通过JVM参数“-XX:MaxTenuringThreshold”来设置

**2.动态分配**  年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代

**3.设置大对象直接进入** 通过JVM参数“-XX:PretenureSizeThreshold”设置字节值[例如1048576字节，即1MB]，超过则直接进入老年代，而无需在新时代复制来复制去

**4.如果Eden区域gc后剩下的存活对象大于survivor区域的大小，则直接加入老年代**



注：*每次GC时都会去判断老年代可用的内存空间大小与当前新生代所有对象的大小*



老年代GC触发场景：

1.Minor GC之前检查发现老年代的可用空间不足以放下可能存活的对象，就会触发Full GC，然后再Minor GC

2.Minor GC之后老年代放不下这么多存活对象，就进行一次Full GC...



**parnew+cms的GC优化？**

优化思路：

*想要达到的目标：尽量减少Full GC，保证对象都在新生代，进入到老年代的速度较慢即可*

*尽量使存活时间短的对象都存活在新生代，存活时间长的尽快进入老年代*

1.分析每秒会新增多少对象在Eden，多长时间触发一次Minor GC，平均一次GC之后会有多少存活对象进入survivor区，该区域能否存放，还要判断不能因为动态年龄直接升入老年代

<u>注：动态分配  年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代</u>

2.可以把分代年龄适度增加，但是适可而止，因为可能会有许多@service，@controller之类的注解创建的对象会被滞留在新生代，这类对象一般还是放在老年代合适

3.修改新生代与老年代的比例，加大新生代

4.修改E区和S区的比例，同1，能让survivor放下GC之后的存活对象就行

5.由于每次GC都会提前去检查空间担保[JDK1.6之后默认检查]，要保证每次Minor GC之后存活的对象平均占用内存小于老年代可用内存，否则会触发Full GC



**G1的优化**

优化思路：

*避免对象过快的加入老年代，减少触发mixed GC*

*尽量使存活时间短的对象都存活在新生代，存活时间长的尽快进入老年代*

1.XX:MaxGCPauseMills

①这个参数用来设置GC时系统可接受的停滞时间，需要灵活变化，如果时间太短，那么对象在加入region之后G1回收器判定在这段短暂的时间内我可以把这些只占用了一丢丢的region给回收掉将会频繁触发GC

②如果时间太长，系统可能容忍你一直添加新对象，最后再一次性回收个几百M，此时系统停滞个500ms

③时间如果太长还有另一个问题，此时新生代累计了许多对象，可能达到占用堆内存的60%，才触发了一次新生代的GC，这个时候存活的对象可能超过了survivor的内存大小或者由于动态年龄判断，会使得存活对象加入老年代，如果老年代region占用了堆内存的45%，那么又会触发一次mixed GC